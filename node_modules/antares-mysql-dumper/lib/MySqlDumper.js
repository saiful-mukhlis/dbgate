"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MySqlDumper = void 0;
const SqlDumper_1 = require("./SqlDumper");
const fieldTypes_1 = require("./tools/fieldTypes");
const hexToBinary_1 = __importDefault(require("./tools/hexToBinary"));
const getArrayDepth_1 = require("./tools/getArrayDepth");
const moment_1 = __importDefault(require("moment"));
const helpers_1 = require("@turf/helpers");
const MySqlClient_1 = require("./MySqlClient");
class MySqlDumper extends SqlDumper_1.SqlDumper {
    constructor(options) {
        const client = new MySqlClient_1.MySqlClient(options.connection, options.schema);
        super(client, options.tables, options);
    }
    getSqlHeader() {
        const _super = Object.create(null, {
            getSqlHeader: { get: () => super.getSqlHeader }
        });
        return __awaiter(this, void 0, void 0, function* () {
            let dump = yield _super.getSqlHeader.call(this);
            dump += `


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
SET NAMES utf8mb4;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;`;
            return dump;
        });
    }
    getSqlFooter() {
        const _super = Object.create(null, {
            getSqlFooter: { get: () => super.getSqlFooter }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const footer = yield _super.getSqlFooter.call(this);
            return `/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;

${footer}
`;
        });
    }
    getCreateTable(tableName) {
        return __awaiter(this, void 0, void 0, function* () {
            const { rows } = yield this._client.raw(`SHOW CREATE TABLE \`${this.schemaName}\`.\`${tableName}\``);
            if (rows.length !== 1)
                return "";
            const col = "Create View" in rows[0] ? "Create View" : "Create Table";
            return rows[0][col] + ";";
        });
    }
    getDropTable(tableName) {
        return `DROP TABLE IF EXISTS \`${tableName}\`;`;
    }
    loadTables() {
        return __awaiter(this, void 0, void 0, function* () {
            const { rows } = yield this._client.raw(`SELECT TABLE_NAME FROM information_schema.tables where TABLE_SCHEMA = \'${this.schemaName}\' AND TABLE_TYPE = 'BASE TABLE'`);
            return rows.map((x) => x.TABLE_NAME);
        });
    }
    getTableInsert(tableName) {
        return __asyncGenerator(this, arguments, function* getTableInsert_1() {
            var e_1, _a;
            let rowCount = 0;
            let sqlStr = "";
            const countResults = yield __await(this._client.raw(`SELECT COUNT(1) as count FROM \`${this.schemaName}\`.\`${tableName}\``));
            if (countResults.rows.length === 1)
                rowCount = countResults.rows[0].count;
            if (rowCount > 0) {
                let queryLength = 0;
                let rowsWritten = 0;
                let rowIndex = 0;
                const sqlInsertDivider = this._options.sqlInsertDivider || "rows";
                const sqlInsertAfter = this._options.sqlInsertAfter || 250;
                const columns = yield __await(this._client.getTableColumns({
                    table: tableName,
                    schema: this.schemaName,
                }));
                const notGeneratedColumns = columns.filter((col) => !col.generated);
                const columnNames = notGeneratedColumns.map((col) => "`" + col.name + "`");
                const insertStmt = `INSERT INTO \`${tableName}\` (${columnNames.join(", ")}) VALUES`;
                sqlStr += `LOCK TABLES \`${tableName}\` WRITE;\n`;
                sqlStr += `/*!40000 ALTER TABLE \`${tableName}\` DISABLE KEYS */;`;
                sqlStr += "\n\n";
                yield yield __await(sqlStr);
                yield yield __await(insertStmt);
                const stream = yield __await(this._queryStream(`SELECT ${columnNames.join(", ")} FROM \`${this.schemaName}\`.\`${tableName}\``));
                try {
                    for (var stream_1 = __asyncValues(stream), stream_1_1; stream_1_1 = yield __await(stream_1.next()), !stream_1_1.done;) {
                        const row = stream_1_1.value;
                        if (this.isCancelled) {
                            stream.destroy();
                            yield yield __await(null);
                            return yield __await(void 0);
                        }
                        let sqlInsertString = "";
                        if ((sqlInsertDivider === "bytes" &&
                            queryLength >= sqlInsertAfter * 1024) ||
                            (sqlInsertDivider === "rows" && rowsWritten === sqlInsertAfter)) {
                            sqlInsertString += `;\n${insertStmt}\n\t(`;
                            queryLength = 0;
                            rowsWritten = 0;
                        }
                        else if (rowIndex === 0)
                            sqlInsertString += "\n\t(";
                        else
                            sqlInsertString += ",\n\t(";
                        for (const i in notGeneratedColumns) {
                            const column = notGeneratedColumns[i];
                            const val = row[column.name];
                            if (val === null)
                                sqlInsertString += "NULL";
                            else if (fieldTypes_1.DATE.includes(column.type)) {
                                sqlInsertString += (0, moment_1.default)(val).isValid()
                                    ? this.escapeAndQuote((0, moment_1.default)(val).format("YYYY-MM-DD"))
                                    : val;
                            }
                            else if (fieldTypes_1.DATETIME.includes(column.type)) {
                                let datePrecision = "";
                                for (let i = 0; i < column.precision; i++)
                                    datePrecision += i === 0 ? ".S" : "S";
                                sqlInsertString += (0, moment_1.default)(val).isValid()
                                    ? this.escapeAndQuote((0, moment_1.default)(val).format(`YYYY-MM-DD HH:mm:ss${datePrecision}`))
                                    : this.escapeAndQuote(val);
                            }
                            else if (fieldTypes_1.BIT.includes(column.type))
                                sqlInsertString += `b'${(0, hexToBinary_1.default)(Buffer.from(val).toString("hex"))}'`;
                            else if (fieldTypes_1.BLOB.includes(column.type))
                                sqlInsertString += `X'${val.toString("hex").toUpperCase()}'`;
                            else if (fieldTypes_1.NUMBER.includes(column.type))
                                sqlInsertString += val;
                            else if (fieldTypes_1.FLOAT.includes(column.type))
                                sqlInsertString += parseFloat(val);
                            else if (fieldTypes_1.SPATIAL.includes(column.type)) {
                                let geoJson;
                                if (fieldTypes_1.IS_MULTI_SPATIAL.includes(column.type)) {
                                    const features = [];
                                    for (const element of val)
                                        features.push(this.getMarkers(element));
                                    geoJson = {
                                        type: "FeatureCollection",
                                        features,
                                    };
                                }
                                else
                                    geoJson = this._getGeoJSON(val);
                                sqlInsertString += `ST_GeomFromGeoJSON('${JSON.stringify(geoJson)}')`;
                            }
                            else if (val === "")
                                sqlInsertString += "''";
                            else {
                                sqlInsertString +=
                                    typeof val === "string"
                                        ? this.escapeAndQuote(val)
                                        : typeof val === "object"
                                            ? this.escapeAndQuote(JSON.stringify(val))
                                            : val;
                            }
                            if (parseInt(i) !== notGeneratedColumns.length - 1)
                                sqlInsertString += ", ";
                        }
                        sqlInsertString += ")";
                        queryLength += sqlInsertString.length;
                        rowsWritten++;
                        rowIndex++;
                        yield yield __await(sqlInsertString);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (stream_1_1 && !stream_1_1.done && (_a = stream_1.return)) yield __await(_a.call(stream_1));
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                sqlStr = ";\n\n";
                sqlStr += `/*!40000 ALTER TABLE \`${tableName}\` ENABLE KEYS */;\n`;
                sqlStr += "UNLOCK TABLES;";
                yield yield __await(sqlStr);
            }
        });
    }
    getMarkers(points) {
        if (Array.isArray(points)) {
            if ((0, getArrayDepth_1.getArrayDepth)(points) === 1)
                return (0, helpers_1.lineString)(points.reduce((acc, curr) => [...acc, [curr.x, curr.y]], []));
            else
                return (0, helpers_1.polygon)(points.map((arr) => arr.reduce((acc, curr) => [...acc, [curr.x, curr.y]], [])));
        }
        else
            return (0, helpers_1.point)([points.x, points.y]);
    }
    getViewText(name) {
        return __awaiter(this, void 0, void 0, function* () {
            let sqlString = "";
            const viewSyntax = yield this.getCreateTable(name);
            sqlString += viewSyntax.replace(new RegExp("`" + this.schemaName + "`.", "g"), "");
            sqlString += "\n";
            return sqlString;
        });
    }
    getViews() {
        return __awaiter(this, void 0, void 0, function* () {
            const { rows: views } = yield this._client.raw(`SHOW TABLE STATUS FROM \`${this.schemaName}\` WHERE Comment = 'VIEW'`);
            let sqlString = "";
            const viewTexts = {};
            for (const view of views) {
                viewTexts[view.Name] = yield this.getViewText(view.Name);
            }
            let viewsOrdered = [];
            let viewsRest = views.map((x) => x.Name);
            while (viewsRest.length > 0) {
                let minima = null;
                for (const candidate of viewsRest) {
                    let candidateOk = true;
                    for (const test of viewsRest) {
                        if (test == candidate) {
                            continue;
                        }
                        if (viewTexts[candidate] &&
                            viewTexts[candidate].toUpperCase().includes(test.toUpperCase())) {
                            candidateOk = false;
                            break;
                        }
                    }
                    if (candidateOk) {
                        minima = candidate;
                        break;
                    }
                }
                if (minima == null) {
                    minima = viewsRest[0];
                }
                viewsOrdered = [...viewsOrdered, minima];
                viewsRest = viewsRest.filter((x) => x != minima);
            }
            for (const view of viewsOrdered) {
                sqlString += `DROP VIEW IF EXISTS \`${view}\`;\n`;
                sqlString += viewTexts[view];
            }
            return sqlString;
        });
    }
    getTriggers() {
        return __awaiter(this, void 0, void 0, function* () {
            const { rows: triggers } = yield this._client.raw(`SHOW TRIGGERS FROM \`${this.schemaName}\``);
            const generatedTables = this._tables
                .filter((t) => t.includeStructure)
                .map((t) => t.table);
            let sqlString = "";
            for (const trigger of triggers) {
                const { Trigger: name, Timing: timing, Event: event, Table: table, Statement: statement, sql_mode: sqlMode, } = trigger;
                if (!generatedTables.includes(table))
                    continue;
                const definer = this.getEscapedDefiner(trigger.Definer);
                sqlString += "/*!50003 SET @OLD_SQL_MODE=@@SQL_MODE*/;;\n";
                sqlString += `/*!50003 SET SQL_MODE="${sqlMode}" */;\n`;
                sqlString += "DELIMITER ;;\n";
                sqlString += "/*!50003 CREATE*/ ";
                sqlString += `/*!50017 DEFINER=${definer}*/ `;
                sqlString += `/*!50003 TRIGGER \`${name}\` ${timing} ${event} ON \`${table}\` FOR EACH ROW ${statement}*/;;\n`;
                sqlString += "DELIMITER ;\n";
                sqlString += "/*!50003 SET SQL_MODE=@OLD_SQL_MODE */;\n\n";
            }
            return sqlString;
        });
    }
    getSchedulers() {
        return __awaiter(this, void 0, void 0, function* () {
            const { rows: schedulers } = yield this._client.raw(`SELECT *, EVENT_SCHEMA AS \`Db\`, EVENT_NAME AS \`Name\` FROM information_schema.\`EVENTS\` WHERE EVENT_SCHEMA = '${this.schemaName}'`);
            let sqlString = "";
            for (const scheduler of schedulers) {
                const { EVENT_NAME: name, SQL_MODE: sqlMode, EVENT_TYPE: type, INTERVAL_VALUE: intervalValue, INTERVAL_FIELD: intervalField, STARTS: starts, ENDS: ends, EXECUTE_AT: at, ON_COMPLETION: onCompletion, STATUS: status, EVENT_DEFINITION: definition, } = scheduler;
                const definer = this.getEscapedDefiner(scheduler.DEFINER);
                const comment = this.escapeAndQuote(scheduler.EVENT_COMMENT);
                sqlString += `/*!50106 DROP EVENT IF EXISTS \`${name}\` */;\n`;
                sqlString += "/*!50003 SET @OLD_SQL_MODE=@@SQL_MODE*/;;\n";
                sqlString += `/*!50003 SET SQL_MODE='${sqlMode}' */;\n`;
                sqlString += "DELIMITER ;;\n";
                sqlString += "/*!50106 CREATE*/ ";
                sqlString += `/*!50117 DEFINER=${definer}*/ `;
                sqlString += `/*!50106 EVENT \`${name}\` ON SCHEDULE `;
                if (type === "RECURRING") {
                    sqlString += `EVERY ${intervalValue} ${intervalField} STARTS '${starts}' `;
                    if (ends)
                        sqlString += `ENDS '${ends}' `;
                }
                else
                    sqlString += `AT '${at}' `;
                sqlString += `ON COMPLETION ${onCompletion} ${status === "disabled" ? "DISABLE" : "ENABLE"} COMMENT ${comment || "''"} DO ${definition}*/;;\n`;
                sqlString += "DELIMITER ;\n";
                sqlString += "/*!50003 SET SQL_MODE=@OLD_SQL_MODE*/;;\n";
            }
            return sqlString;
        });
    }
    getFunctions() {
        return __awaiter(this, void 0, void 0, function* () {
            const { rows: functions } = yield this._client.raw(`SHOW FUNCTION STATUS WHERE \`Db\` = '${this.schemaName}';`);
            let sqlString = "";
            for (const func of functions) {
                const definer = this.getEscapedDefiner(func.Definer);
                sqlString += yield this.getRoutineSyntax(func.Name, func.Type, definer);
            }
            return sqlString;
        });
    }
    getRoutines() {
        return __awaiter(this, void 0, void 0, function* () {
            const { rows: routines } = yield this._client.raw(`SHOW PROCEDURE STATUS WHERE \`Db\` = '${this.schemaName}';`);
            let sqlString = "";
            for (const routine of routines) {
                const definer = this.getEscapedDefiner(routine.Definer);
                sqlString += yield this.getRoutineSyntax(routine.Name, routine.Type, definer);
            }
            return sqlString;
        });
    }
    getRoutineSyntax(name, type, definer) {
        return __awaiter(this, void 0, void 0, function* () {
            const { rows: routines } = yield this._client.raw(`SHOW CREATE ${type} \`${this.schemaName}\`.\`${name}\``);
            if (routines.length === 0)
                return "";
            const routine = routines[0];
            const fieldName = `Create ${type === "PROCEDURE" ? "Procedure" : "Function"}`;
            const sqlMode = routine.sql_mode;
            const createProcedure = routine[fieldName];
            let sqlString = "";
            if (createProcedure) {
                // If procedure body not empty
                const startOffset = createProcedure.indexOf(type);
                const procedureBody = createProcedure.substring(startOffset);
                sqlString += `/*!50003 DROP ${type} IF EXISTS \`${name}\`*/;;\n`;
                sqlString += "/*!50003 SET @OLD_SQL_MODE=@@SQL_MODE*/;;\n";
                sqlString += `/*!50003 SET SQL_MODE="${sqlMode}"*/;;\n`;
                sqlString += "DELIMITER ;;\n";
                sqlString += `/*!50003 CREATE*/ /*!50020 DEFINER=${definer}*/ /*!50003 ${procedureBody}*/;;\n`;
                sqlString += "DELIMITER ;\n";
                sqlString += "/*!50003 SET SQL_MODE=@OLD_SQL_MODE*/;\n";
            }
            return sqlString;
        });
    }
    _queryStream(sql) {
        return __awaiter(this, void 0, void 0, function* () {
            if (process.env.NODE_ENV === "development")
                console.log("EXPORTER:", sql);
            const connection = this._client.connection;
            const stream = connection.query(sql).stream();
            // const dispose = () => connection.destroy();
            // const dispose = () => {};
            // stream.on("end", dispose);
            // stream.on("error", dispose);
            // stream.on("close", dispose);
            return stream;
        });
    }
    getEscapedDefiner(definer) {
        return definer
            .split("@")
            .map((part) => "`" + part + "`")
            .join("@");
    }
    escapeAndQuote(val) {
        // eslint-disable-next-line no-control-regex
        const CHARS_TO_ESCAPE = /[\0\b\t\n\r\x1a"'\\]/g;
        const CHARS_ESCAPE_MAP = {
            "\0": "\\0",
            "\b": "\\b",
            "\t": "\\t",
            "\n": "\\n",
            "\r": "\\r",
            "\x1a": "\\Z",
            '"': '\\"',
            "'": "\\'",
            "\\": "\\\\",
        };
        let chunkIndex = (CHARS_TO_ESCAPE.lastIndex = 0);
        let escapedVal = "";
        let match;
        while ((match = CHARS_TO_ESCAPE.exec(val))) {
            escapedVal +=
                val.slice(chunkIndex, match.index) + CHARS_ESCAPE_MAP[match[0]];
            chunkIndex = CHARS_TO_ESCAPE.lastIndex;
        }
        if (chunkIndex === 0)
            return `'${val}'`;
        if (chunkIndex < val.length)
            return `'${escapedVal + val.slice(chunkIndex)}'`;
        return `'${escapedVal}'`;
    }
    _getGeoJSON(val) {
        if (Array.isArray(val)) {
            if ((0, getArrayDepth_1.getArrayDepth)(val) === 1)
                return (0, helpers_1.lineString)(val.reduce((acc, curr) => [...acc, [curr.x, curr.y]], []));
            else
                return (0, helpers_1.polygon)(val.map((arr) => arr.reduce((acc, curr) => [...acc, [curr.x, curr.y]], [])));
        }
        else
            return (0, helpers_1.point)([val.x, val.y]);
    }
}
exports.MySqlDumper = MySqlDumper;
