"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SqlDumper = void 0;
const BaseDumper_1 = require("./BaseDumper");
class SqlDumper extends BaseDumper_1.BaseDumper {
    constructor(client, tables, options) {
        super(tables, options);
        this._client = client;
        this._commentChar = "#";
    }
    get schemaName() {
        return this._client.schema;
    }
    // get host() {
    //   return this._client._params.host;
    // }
    getServerVersion() {
        return __awaiter(this, void 0, void 0, function* () {
            const version = yield this._client.getVersion();
            return `${version.name} ${version.number}`;
        });
    }
    loadTables() {
        return __awaiter(this, void 0, void 0, function* () {
            return [];
        });
    }
    ensureTables() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._tables) {
                this._tables = (yield this.loadTables()).map((table) => ({
                    table,
                    includeStructure: true,
                    includeContent: true,
                    includeDropStatement: true,
                }));
            }
        });
    }
    dump() {
        var e_1, _a;
        return __awaiter(this, void 0, void 0, function* () {
            yield this.ensureTables();
            const includes = this._options.includes || {
                views: true,
                triggers: true,
                routines: true,
                functions: true,
                schedulers: true,
            };
            const extraItems = Object.keys(includes).filter((key) => includes[key]);
            const totalTableToProcess = this._tables.filter((t) => t.includeStructure || t.includeContent || t.includeDropStatement).length;
            const processingItemCount = totalTableToProcess + extraItems.length;
            const exportState = {
                totalItems: processingItemCount,
                currentItemIndex: 0,
                currentItem: "",
                op: "",
            };
            const header = yield this.getSqlHeader();
            this.writeString(header);
            this.writeString("\n\n\n");
            for (const item of this._tables) {
                // user abort operation
                if (this.isCancelled)
                    return;
                // skip item if not set to output any detail for them
                if (!item.includeStructure &&
                    !item.includeContent &&
                    !item.includeDropStatement)
                    continue;
                exportState.currentItemIndex++;
                exportState.currentItem = item.table;
                exportState.op = "FETCH";
                this.emitUpdate(exportState);
                const tableHeader = this.buildComment(`Dump of table ${item.table}\n------------------------------------------------------------`);
                this.writeString(tableHeader);
                this.writeString("\n\n");
                if (item.includeDropStatement) {
                    const dropTableSyntax = this.getDropTable(item.table);
                    this.writeString(dropTableSyntax);
                    this.writeString("\n\n");
                }
                if (item.includeStructure) {
                    const createTableSyntax = yield this.getCreateTable(item.table);
                    this.writeString(createTableSyntax);
                    this.writeString("\n\n");
                }
                if (item.includeContent) {
                    exportState.op = "WRITE";
                    this.emitUpdate(exportState);
                    try {
                        for (var _b = (e_1 = void 0, __asyncValues(this.getTableInsert(item.table))), _c; _c = yield _b.next(), !_c.done;) {
                            const sqlStr = _c.value;
                            if (this.isCancelled)
                                return;
                            this.writeString(sqlStr);
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (_c && !_c.done && (_a = _b.return)) yield _a.call(_b);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                    this.writeString("\n\n");
                }
                this.writeString("\n\n");
            }
            for (const item of extraItems) {
                const processingMethod = `get${item.charAt(0).toUpperCase() + item.slice(1)}`;
                exportState.currentItemIndex++;
                exportState.currentItem = item;
                exportState.op = "PROCESSING";
                this.emitUpdate(exportState);
                if (this[processingMethod]) {
                    const data = yield this[processingMethod]();
                    if (data !== "") {
                        const header = this.buildComment(`Dump of ${item}\n------------------------------------------------------------`) + "\n\n";
                        this.writeString(header);
                        this.writeString(data);
                        this.writeString("\n\n");
                    }
                }
            }
            const footer = yield this.getSqlFooter();
            this.writeString(footer);
        });
    }
    buildComment(text) {
        return text
            .split("\n")
            .map((txt) => `${this._commentChar} ${txt}`)
            .join("\n");
    }
    getSqlHeader() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._options.getHeader) {
                const serverVersion = yield this.getServerVersion();
                const header = this._options.getHeader({
                    serverVersion,
                    schema: this.schemaName,
                });
                if (header) {
                    return this.buildComment(header);
                }
            }
            return "";
        });
    }
    getSqlFooter() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._options.getFooter) {
                return this.buildComment(this._options.getFooter());
            }
            return "";
        });
    }
    getCreateTable(tableName) {
        throw new Error('Sql Exporter must implement the "getCreateTable" method');
    }
    getDropTable(tableName) {
        throw new Error('Sql Exporter must implement the "getDropTable" method');
    }
    getTableInsert(tableName) {
        throw new Error('Sql Exporter must implement the "getTableInsert" method');
    }
}
exports.SqlDumper = SqlDumper;
